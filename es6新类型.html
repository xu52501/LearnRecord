<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
  const s = Symbol('symbol');

  const obj = {
    c: 'mine',
    [Symbol('symbol1')]: 'hw1',
  };
  obj[s] = 'hw';

  console.log(obj);

  for (const key in obj) {
    console.log(key);
  }

  var keys = Object.getOwnPropertySymbols(obj);
  console.log(keys);

  // Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值
  // Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值
  console.log(Symbol.for("name") === Symbol.for("name"));

  console.log(Symbol("name") === Symbol("name"));


  // set和map
  // ES6 提供了新的数据结构 Set.它类似于数组，但是成员的值都是唯一的，没有重复的值，它本身是一个构造函数，用来生成 Set 数据结构。
  const set = new Set([1,2,3,4,56,345,123,1,43,34,1,23,1,2,234]);
  console.log(set);
  // 去重
  const arr = [...set];

  // ES6 提供了 Map 数据结构，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适
  const map = new Map();
  const o = {str: 'hello'};
  map.set(o, 'world');
  console.log(map, map.get(o), map.has(o));

  const k1 = ['a'];
  const k2 = ['a'];

  map.set(k1, 111).set(k2, 222);

  map.get(k1) // 111
  map.get(k2) // 222
  // 上面例子表明，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键，因为 k1 和 k2 是两个不同的对象，放在不同的内存地址中，所以Map视为不同的键
  </script>
</body>
</html>